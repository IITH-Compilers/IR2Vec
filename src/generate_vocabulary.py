# ------------------------------------------------------------------------------
#
# Part of the IR2Vec Project, under the Apache License v2.0 with LLVM
# Exceptions. See the LICENSE file for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ------------------------------------------------------------------------------

import argparse
import sys
import os


class VocabularyError(Exception):
    """Custom exception for vocabulary errors."""

    pass


# Common header strings
HEADER_GENERATED = "// Generated by IR2Vec. DO NOT EDIT!\n"
HEADER_VOCABULARY_BASE = "// This file defines the base class for vocabulary and the factory \n// for creating vocabulary instances used by IR2Vec.\n"
HEADER_VOCABULARY_CLASS = (
    "// This file defines the {class_name} vocabulary class used by IR2Vec.\n"
)
HEADER_CLANG_FORMAT_OFF = "// clang-format off\n"


def write_file(file_path, content):
    try:
        with open(file_path, "w") as fw:
            fw.write(content)
    except IOError as e:
        raise VocabularyError(f"Failed to write to {file_path}: {e}")


def generate_base_vocabulary_header():
    return (
        f"{HEADER_GENERATED}"
        f"{HEADER_VOCABULARY_BASE}"
        f"{HEADER_CLANG_FORMAT_OFF}\n"
        "#ifndef __VOCABULARY_H__\n"
        "#define __VOCABULARY_H__\n\n"
        "#include <map>\n"
        "#include <string>\n"
        "#include <vector>\n"
        "#include <memory>\n"
        "#include <stdexcept> // For std::invalid_argument\n"
        "namespace IR2Vec {\n\n"
        "using Vector = std::vector<double>;\n\n"
        "class VocabularyBase {\n"
        "public:\n"
        "    virtual ~VocabularyBase() {}\n"
        "    virtual const std::map<std::string, IR2Vec::Vector>& getVocabulary() const = 0;\n"
        "};\n\n"
        "class VocabularyFactory {\n"
        "public:\n"
        "    static std::unique_ptr<VocabularyBase> createVocabulary(unsigned dim);\n"
        "};\n\n"
        "} // namespace IR2Vec\n\n"
        "#endif // __VOCABULARY_H__\n"
    )


def generate_vocabulary_class(vocab_file, class_name):
    class_header = (
        f"{HEADER_GENERATED}"
        f"{HEADER_VOCABULARY_CLASS.format(class_name=class_name)}"
        f"{HEADER_CLANG_FORMAT_OFF}\n"
        f"#ifndef __{class_name.upper()}__\n"
        f"#define __{class_name.upper()}__\n\n"
        f"#include <map>\n"
        f"#include <string>\n"
        f"#include <vector>\n"
        f'#include "Vocabulary.h" // Include the base class\n\n'
        f"namespace IR2Vec {{\n\n"
        f"class {class_name} : public VocabularyBase {{\n"
        f"public:\n"
        f"    const std::map<std::string, IR2Vec::Vector>& getVocabulary() const override{{\n"
        f"        return vocabulary;\n"
        f"    }}\n"
        f"private:\n"
        f"    static const std::map<std::string, IR2Vec::Vector> vocabulary;\n"
        f"}};\n"
    )

    opening = (
        f"\nconst std::map<std::string, IR2Vec::Vector> {class_name}::vocabulary = {{\n"
    )
    closing = """\
};
} // namespace IR2Vec

#endif // __{class_name.upper()}__
"""
    dim = class_name.replace("Vocabulary", "")
    vector_definitions = ""
    with open(vocab_file, "r") as fr:
        for line in fr.readlines():
            key, val = line.strip().split(":")
            e = val.find("]")
            vector_definitions += (
                f"const IR2Vec::Vector {key}_vector_{dim} = {{  {val[1:e]} }};\n"
            )

    vocabulary_entries = ""
    with open(vocab_file, "r") as fr:
        for line in fr.readlines():
            key, _ = line.strip().split(":")
            vocabulary_entries += f'    {{ "{key}", {key}_vector_{dim} }},\n'

    return class_header + vector_definitions + opening + vocabulary_entries + closing


def generate_vocabulary_factory(class_names):
    factory_header = (
        f"{HEADER_GENERATED}"
        f"{HEADER_VOCABULARY_BASE}"
        f"{HEADER_CLANG_FORMAT_OFF}\n"
        "#include <memory>\n"  # For std::unique_ptr
        '#include "Vocabulary.h"\n\n'
    )

    # Include headers for each vocabulary class
    for class_name in class_names:
        factory_header += f'#include "{class_name}.h"\n'

    factory_header += "\nnamespace IR2Vec {\n\n"

    factory_function = (
        "std::unique_ptr<VocabularyBase> VocabularyFactory::createVocabulary(unsigned dim) {\n"
        "    switch (dim) {\n"
    )

    factory_cases = ""
    for class_name in class_names:
        dim = class_name.replace("Vocabulary", "").replace("D", "")
        factory_cases += f"        case {dim}:\n            return std::make_unique<{class_name}>();\n"

    factory_footer = """\
        default:
            throw std::invalid_argument("Invalid dimension for vocabulary creation.");
    }
}
} // namespace IR2Vec\n
"""
    return factory_header + factory_function + factory_cases + factory_footer


def main():
    parser = argparse.ArgumentParser(
        description="Generate vocabulary and factory files."
    )
    parser.add_argument(
        "type", choices=["vocab", "base"], help="Type of files to generate."
    )
    parser.add_argument(
        "input",
        help="Input vocabulary text file or dimensions as a comma-separated list.",
    )
    parser.add_argument("output", help="Output file path.")

    args = parser.parse_args()
    if args.type is None or args.input is None or args.output is None:
        raise VocabularyError("Type, input, or output not provided.")

    if args.type == "vocab":
        # Generate vocabulary class based on input file
        vocab_file = args.input

        # Extract dimension from the file name
        dim = (
            os.path.splitext(os.path.basename(vocab_file))[0]
            .split("D")[0]
            .split("Vocab")[-1]
        )
        class_name = f"Vocabulary{dim}D"
        vocab_class_code = generate_vocabulary_class(vocab_file, class_name)
        output_file = os.path.join(args.output, f"{class_name}.h")
        write_file(output_file, vocab_class_code)

    elif args.type == "base":
        # Generate base vocabulary header and factory implementation
        base_header_code = generate_base_vocabulary_header()
        output_file = os.path.join(args.output, "Vocabulary.h")
        write_file(output_file, base_header_code)

        # Parse the dimensions from the input and generate class names
        dimensions = args.input.split(",")
        class_names = [
            f"Vocabulary{dim}D" for dim in dimensions
        ]  # Create class names based on dimensions

        factory_code = generate_vocabulary_factory(class_names)
        output_file = os.path.join(args.output, "VocabularyFactory.cpp")
        write_file(output_file, factory_code)


if __name__ == "__main__":
    try:
        main()
    except VocabularyError as e:
        sys.stderr.write(f"Error: {e}\n")  # Write errors to stderr
        sys.exit(1)
